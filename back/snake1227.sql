/*
SQLyog Ultimate v12.09 (64 bit)
MySQL - 5.5.53 : Database - snake
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`snake` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `snake`;

/*Table structure for table `snake_art_tag` */

DROP TABLE IF EXISTS `snake_art_tag`;

CREATE TABLE `snake_art_tag` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `article_id` int(11) NOT NULL DEFAULT '0' COMMENT '文章ID',
  `tag_id` smallint(6) NOT NULL DEFAULT '0' COMMENT '标签ID',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8;

/*Data for the table `snake_art_tag` */

insert  into `snake_art_tag`(`id`,`article_id`,`tag_id`) values (2,1,4),(3,17,5),(4,18,1),(5,4,4),(6,5,4),(8,7,4),(9,6,4),(12,16,4);

/*Table structure for table `snake_articles` */

DROP TABLE IF EXISTS `snake_articles`;

CREATE TABLE `snake_articles` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '文章id',
  `title` varchar(155) NOT NULL COMMENT '文章标题',
  `description` varchar(255) NOT NULL COMMENT '文章描述',
  `keywords` varchar(155) NOT NULL COMMENT '文章关键字',
  `thumbnail` varchar(255) NOT NULL COMMENT '文章缩略图',
  `content` text NOT NULL COMMENT '文章内容',
  `browse` smallint(6) NOT NULL DEFAULT '0' COMMENT '浏览量',
  `status` tinyint(4) NOT NULL DEFAULT '1' COMMENT '状态：0删除 1正常 2关闭',
  `add_time` datetime NOT NULL COMMENT '发布时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=19 DEFAULT CHARSET=utf8;

/*Data for the table `snake_articles` */

insert  into `snake_articles`(`id`,`title`,`description`,`keywords`,`thumbnail`,`content`,`browse`,`status`,`add_time`) values (4,'每天一个linux命令（1）：ls','ls命令用来显示目标列表，在Linux中是使用率较高的命令。ls命令的输出信息可以进行彩色加亮显示，以分区不同类型的文件。','linux,ls','/upload/20171217/fcccccfddb4bc7e935ff51373e393379.jpg','<p><span style=\"font-family: 宋体, SimSun; font-size: 16px;\">ls命令用来显示目录列表，在linux中是使用率较高的命令。ls命令的输出可以进行彩色加亮显示，以区分不同类型的文件。<br/></span></p><p><br/></p><p><span style=\"font-family: 宋体, SimSun; font-size: 16px;\">ls : 不带任何参数，显示文件和目录，不显示隐藏文件，如 . ..等</span></p><p><span style=\"font-family: 宋体, SimSun; font-size: 16px;\">ls -a :列出所有文件，包括隐藏文件，如. 或以.开头的文件<br/></span></p><p><span style=\"font-family: 宋体, SimSun; font-size: 16px;\">ls -l：列出文件或目录的详细信息。此命令可简写为 ll；</span></p><p><span style=\"font-family: 宋体, SimSun; font-size: 16px;\">&nbsp; &nbsp; drwxr-xr-x 3 zwj zwj 4096 Sep 16 09:39 test</span></p><p><span style=\"font-family: 宋体, SimSun; font-size: 16px;\">&nbsp; &nbsp;详解：第一列：第一个字母为d时，表示为目录，为-时表示文件；第2-4位字母表示该文件或目录拥有者的权限，第5-7位表示该目录拥有者所在组的权限，第9-10位表示其他人的权限；<br/></span></p><p><span style=\"font-family: 宋体, SimSun; font-size: 16px;\">&nbsp; &nbsp;第二列：表示该目录下还有几个子目录或文件，包括其本身；<br/></span></p><p style=\"margin: 10px auto; padding: 0px; line-height: 1.5; font-size: 13px; font-family: verdana, &quot;ms song&quot;, 宋体, Arial, 微软雅黑, Helvetica, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"margin: 0px; padding: 0px; line-height: 1.5; font-family: 宋体, SimSun; font-size: 16px;\">&nbsp; &nbsp;第三列：代表文件或者目录的所有者。</span></p><p style=\"margin: 10px auto; padding: 0px; line-height: 1.5; font-size: 13px; font-family: verdana, &quot;ms song&quot;, 宋体, Arial, 微软雅黑, Helvetica, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"margin: 0px; padding: 0px; line-height: 1.5; font-family: 宋体, SimSun; font-size: 16px;\">&nbsp; &nbsp;第四列：代表文件或者目录的所有组。</span></p><p style=\"margin: 10px auto; padding: 0px; line-height: 1.5; font-size: 13px; font-family: verdana, &quot;ms song&quot;, 宋体, Arial, 微软雅黑, Helvetica, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"margin: 0px; padding: 0px; line-height: 1.5; font-family: 宋体, SimSun; font-size: 16px;\">&nbsp; &nbsp;第五列：代表文件或者目录的大小，单位为字节（byte）</span></p><p style=\"margin: 10px auto; padding: 0px; line-height: 1.5; font-size: 13px; font-family: verdana, &quot;ms song&quot;, 宋体, Arial, 微软雅黑, Helvetica, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"margin: 0px; padding: 0px; line-height: 1.5; font-family: 宋体, SimSun; font-size: 16px;\">&nbsp; &nbsp;第六/七/八列：代表文件或者目录的最后修改时间（月/日/时间）（使用[stat 文件名或者目录名] 用以查看文件或者目录的访问时间access，文件或者目录的修改时间modify，文件或者目录的状态改变时间change）</span></p><p style=\"margin: 10px auto; padding: 0px; line-height: 1.5; font-size: 13px; font-family: verdana, &quot;ms song&quot;, 宋体, Arial, 微软雅黑, Helvetica, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"margin: 0px; padding: 0px; line-height: 1.5; font-family: 宋体, SimSun; font-size: 16px;\"> &nbsp; &nbsp;第九列：代表文件名或者目录名</span></p><p style=\"margin: 10px auto; padding: 0px; line-height: 1.5; font-size: 13px; font-family: verdana, &quot;ms song&quot;, 宋体, Arial, 微软雅黑, Helvetica, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"margin: 0px; padding: 0px; line-height: 1.5; font-family: 宋体, SimSun; font-size: 16px;\">ls -t:以修改时间排序列出</span></p><p style=\"margin: 10px auto; padding: 0px; line-height: 1.5; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-family:宋体, SimSun\">ls -d:显示当前所在目录自身属性，不显示其子目录和文件的属性；</span></p><p style=\"margin: 10px auto; padding: 0px; line-height: 1.5; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-family:宋体, SimSun\">ls -h:与l配合使用，ls -lh:显示更容易理解的方式显示文件信息，如文件大小以k/m/g为单位<br/></span></p><p style=\"margin: 10px auto; padding: 0px; line-height: 1.5; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-family:宋体, SimSun\">ls -R:显示所有子目录及文件</span></p>',0,1,'2017-12-17 23:03:22'),(5,'每天一个linux命令（2）：cd','linux最基本的命令','linux,cd','/upload/20171218/4e74c078cae8f2919c2003f632be5198.jpg','<p>cd ：切换至目录<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;cd / &nbsp; &nbsp;:切换至根目录下<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;cd ../ &nbsp;：切换到上层目录<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;cd ./目录1/目录2/ &nbsp;切换至当前目录下的某个子目录下<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;cd /目录1/目录2/ &nbsp; 切换至根目录下的某个子目录下<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;cd - &nbsp; &nbsp;返回进入此目录之前的目录；一直使用此命令，会在两个目录来回切换，并不会一直回退<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;cd &nbsp;从任何目录返回至home目录<br/></p><p>&nbsp; &nbsp;&nbsp;<img src=\"/upload/image/20171218/1513603754727237.png\" title=\"1513603754727237.png\" alt=\"blob.png\"/></p>',0,1,'2017-12-18 21:33:18'),(6,'linux 自动备份脚本','数据库自动备份','linux,mysql,备份','/upload/20171227/91a82b3771d2b3547e2b4f0cb0a2b115.png','<p><span style=\"font-weight: bold;\">备份脚本：</span></p><p>#!/bin/bash</p><p># MYSQLDBUSERNAME是MySQL数据库的用户名，可自定义</p><p>MYSQLDBUSERNAME=username</p><p># MYSQLDBPASSWORD是MySQL数据库的密码，可自定义</p><p>MYSQLDBPASSWORD=XXXXX</p><p># MYSQBASEDIR是MySQL数据库的安装目录，--prefix=$MYSQBASEDIR，可自定义</p><p>MYSQBASEDIR=/usr/local/mysql</p><p># MYSQL是mysql命令的绝对路径，可自定义</p><p>MYSQL=$MYSQBASEDIR/bin/mysql</p><p># MYSQLDUMP是mysqldump命令的绝对路径，可自定义</p><p>MYSQLDUMP=$MYSQBASEDIR/bin/mysqldump</p><p># BACKDIR是数据库备份的存放地址，可以自定义修改成远程地址</p><p>BACKDIR=/practice_test/crontabTestData/db/</p><p># 获取当前时间，格式为：年-月-日，用于生成以这种时间格式的目录名称</p><p>DATEFORMATTYPE1=$(date +%Y-%m-%d)</p><p># 获取当前时间，格式为：年月日时分秒，用于生成以这种时间格式的文件名称</p><p>DATEFORMATTYPE2=$(date +%Y%m%d%H%M%S)</p><p># 如果存在MYSQBASEDIR目录，则将MYSQDATADIR设置为$MYSQBASEDIR/data，具体是什么路径，就把data改成什么路径，否则将MYSQBASEDIR设定为/var/lib/mysql，可自定义</p><p>[ -d $MYSQBASEDIR ] &amp;&amp; MYSQDATADIR=$MYSQBASEDIR/data || MYSQDATADIR=/var/lib/mysql</p><p># 如果mysql命令存在并可执行，则继续，否则将MYSQL设定为mysql，默认路径下的mysql</p><p>[ -x $MYSQL ] || MYSQL=mysql</p><p># 如果mysqldump命令存在并可执行，则继续，否则将MYSQLDUMP设定为mysqldump，默认路径下的mysqldump</p><p>[ -x $MYSQLDUMP ] || MYSQLDUMP=mysqldump</p><p># 如果不存在备份目录则创建这个目录</p><p>[ -d ${BACKDIR} ] || mkdir -p ${BACKDIR}</p><p>[ -d ${BACKDIR}/${DATEFORMATTYPE1} ] || mkdir ${BACKDIR}/${DATEFORMATTYPE1}</p><p># 获取MySQL中有哪些数据库，根据mysqldatadir下的目录名字来确认，此处可以自定义，TODO</p><p>DBLIST=`ls -p $MYSQDATADIR | grep / |tr -d /`</p><p># 从数据库列表中循环取出数据库名称，执行备份操作</p><p>for DBNAME in $DBLIST</p><p># mysqldump skip one table</p><p># -- Warning: Skipping the data of table mysql.event. Specify the --events option explicitly.</p><p># mysqldump --ignore-table=mysql.event</p><p># http://serverfault.com/questions/376904/mysqldump-skip-one-table</p><p># --routines，备份存储过程和函数</p><p># --events，跳过mysql.event表</p><p># --triggers，备份触发器</p><p># --single-transaction，针对InnoDB，在单次事务中通过转储所有数据库表创建一个一致性的快照，此选项会导致自动锁表，因此不需要--lock-all-tables</p><p># --flush-logs，在dump转储前刷新日志</p><p># --ignore-table，忽略某个表，--ignore-table=database.table</p><p># --master-data=2 ，如果启用MySQL复制功能，则可以添加这个选项</p><p># 将dump出的sql语句用gzip压缩到一个以时间命名的文件</p><p>do ${MYSQLDUMP} --user=${MYSQLDBUSERNAME} --password=${MYSQLDBPASSWORD} --routines --events --triggers --single-transaction --flush-logs --ignore-table=mysql.event --databases ${DBNAME} | gzip &gt; ${BACKDIR}/${DATEFORMATTYPE1}/${DBNAME}-backup-${DATEFORMATTYPE2}.sql.gz</p><p># 检查执行结果，如果错误代码为0则输出成功，否则输出失败</p><p>[ $? -eq 0 ] &amp;&amp; echo &quot;${DBNAME} has been backuped successful&quot; || echo &quot;${DBNAME} has been backuped failed&quot;</p><p># 等待5s，可自定义</p><p>/bin/sleep 5</p><p>done</p><p><br/></p>',1,1,'2017-12-18 22:14:19'),(7,'每天一个linux命令（3）：pwd','pwd 命令来查看”当前工作目录“的完整路径。','linux,pwd','/upload/20171220/b89ee204e3627849afbf27e605835b8c.jpg','<p style=\"margin: 0 auto 0 28px;padding: 0px;text-indent: 28px;color: rgb(51, 51, 51);font-family: Verdana, Arial, Helvetica, sans-serif;font-size: 13.3333px;white-space: normal;background-color: rgb(255, 255, 255)\"><span style=\"padding: 0px; font-family: 宋体, SimSun; font-size: 16px; color: rgb(0, 0, 0);\"></span></p><p style=\"margin: 10px auto; font-family: verdana, sans-serif; font-size: 13px; white-space: normal; background-color: rgb(255, 255, 255);\"><strong>语法</strong></p><p style=\"margin: 10px auto; font-family: verdana, sans-serif; font-size: 13px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 14px;\">pwd [ -L | -P ]</span></p><p style=\"margin: 10px auto; font-family: verdana, sans-serif; font-size: 13px; white-space: normal; background-color: rgb(255, 255, 255);\"><strong>描述</strong></p><p style=\"margin: 10px auto; font-family: verdana, sans-serif; font-size: 13px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 宋体, SimSun; font-size: 16px;\">pwd 命令将当前目录的全路径名称（从根目录）写入标准输出。全部目录使用 /（斜线）分隔。第一个 / 表示根目录，最后一个目录是当前目录。</span></p><p style=\"margin: 10px auto; font-family: verdana, sans-serif; font-size: 13px; white-space: normal; background-color: rgb(255, 255, 255);\"><strong>标志</strong></p><p style=\"margin: 10px auto; font-family: verdana, sans-serif; font-size: 13px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 宋体, SimSun; font-size: 16px;\">-L</span></p><p style=\"margin: 10px auto; font-family: verdana, sans-serif; font-size: 13px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 宋体, SimSun; font-size: 16px;\">如果 PWD 环境变量包含了不包含文件名 .（点）或 ..（点点）的当前目录的绝对路径名，则显示 PWD 环境变量的值。否则，-L 标志与 -P 标志一样运行。</span></p><p style=\"margin: 10px auto; font-family: verdana, sans-serif; font-size: 13px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 宋体, SimSun; font-size: 16px;\">-P</span></p><p style=\"margin: 10px auto; font-family: verdana, sans-serif; font-size: 13px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 宋体, SimSun; font-size: 16px;\">显示当前目录的绝对路径名。与 -P 标志一起显示的绝对路径不包含在路径名的绝对路径中涉及到符号链接类型的文件的名称。</span></p><p style=\"margin: 10px auto; font-family: verdana, sans-serif; font-size: 13px; white-space: normal; background-color: rgb(255, 255, 255);\"><br/></p><p style=\"margin: 0 auto 0 28px;padding: 0px;text-indent: 28px;color: rgb(51, 51, 51);font-family: Verdana, Arial, Helvetica, sans-serif;font-size: 13.3333px;white-space: normal;background-color: rgb(255, 255, 255)\"><span style=\"color: rgb(0, 0, 0); padding: 0px; font-size: 14px; font-family: 宋体;\"></span><br/></p><p><br/></p>',0,1,'2017-12-20 21:41:51'),(8,'每天一个linux命令（4）：mkdir','mkdir用来创建指定名称的目录（文件夹），要求执行创建的用户拥有写权限，并且不能创建已有的目录。','linux,mkdir','/upload/20171220/883aa3ab559fdd0d3144a3eb9cbd0b4c.jpg','<p><span style=\"font-family: 宋体, SimSun;\"><span style=\"color: rgb(51, 51, 51); font-size: 14px; text-indent: 28px; background-color: rgb(255, 255, 255);\">通过&nbsp;</span>mkdir</span><span style=\"font-family:Times New Roman\">&nbsp;</span><span style=\"font-family:宋体\">命令可以实现在指定位置创建以&nbsp;</span><span style=\"font-family:Times New Roman\">DirName(</span><span style=\"font-family:宋体\">指定的文件名</span><span style=\"font-family:Times New Roman\">)</span><span style=\"font-family:宋体\">命名的文件夹或目录。要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。并且，所创建的文件夹</span><span style=\"font-family:Times New Roman\">(</span><span style=\"font-family:宋体\">目录</span><span style=\"font-family:Times New Roman\">)</span><span style=\"font-family:宋体\">不能与其父目录</span><span style=\"font-family:Times New Roman\">(</span><span style=\"font-family:宋体\">即父文件夹</span><span style=\"font-family:Times New Roman\">)</span><span style=\"font-family:宋体\">中的文件名重名，即同一个目录下不能有同名的</span><span style=\"font-family:Times New Roman\">(</span><span style=\"font-family:宋体\">区分大小写</span><span style=\"font-family:Times New Roman\">)</span><span style=\"font-family:宋体\">。</span></p><p><span style=\"font-family: 宋体; font-size: 14px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); text-indent: 28px;\">&nbsp;&nbsp;&nbsp;&nbsp;-m,&nbsp;--mode=</span><span style=\"font-family: 宋体; font-size: 14px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); text-indent: 28px;\">模式，设定权限</span><span style=\"font-size: 14px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); text-indent: 28px; font-family: &quot;Times New Roman&quot;;\">&lt;</span><span style=\"font-family: 宋体; font-size: 14px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); text-indent: 28px;\">模式</span><span style=\"font-size: 14px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); text-indent: 28px; font-family: &quot;Times New Roman&quot;;\">&gt;&nbsp;(</span><span style=\"font-family: 宋体; font-size: 14px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); text-indent: 28px;\">类似&nbsp;</span><span style=\"font-size: 14px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); text-indent: 28px; font-family: &quot;Times New Roman&quot;;\">chmod)</span><span style=\"font-family: 宋体; font-size: 14px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); text-indent: 28px;\">，而不是&nbsp;</span><span style=\"font-size: 14px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); text-indent: 28px; font-family: &quot;Times New Roman&quot;;\">rwxrwxrwx&nbsp;</span><span style=\"font-family: 宋体; font-size: 14px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); text-indent: 28px;\">减&nbsp;</span><span style=\"font-size: 14px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); text-indent: 28px; font-family: &quot;Times New Roman&quot;;\">umask</span></p><p style=\"margin: 0 auto 0 28px;padding: 0px;text-indent: 28px;color: rgb(51, 51, 51);font-family: Verdana, Arial, Helvetica, sans-serif;font-size: 13.3333px;white-space: normal;background-color: rgb(255, 255, 255)\"><span style=\";padding: 0px;font-size: 14px;font-family: 宋体\">-p,&nbsp;--parents&nbsp;&nbsp;</span><span style=\";padding: 0px;color: rgb(42, 42, 42);font-size: 14px;font-family: &#39;Segoe UI&#39;;background-color: rgb(245, 250, 255)\">可以是一个路径名称。此时若路径中的某些目录尚不存在<span style=\"font-family:Segoe UI\">,</span><span style=\"font-family:宋体\">加上此选项后</span><span style=\"font-family:Segoe UI\">,</span><span style=\"font-family:宋体\">系统将自动建立好那些尚不存在的目录</span><span style=\"font-family:Segoe UI\">,</span><span style=\"font-family:宋体\">即一次可以建立多个目录</span><span style=\"font-family:Segoe UI\">;</span></span><span style=\";padding: 0px;font-size: 14px;font-family: &#39;Times New Roman&#39;\">&nbsp;</span></p><p style=\"margin: 0 auto 0 28px;padding: 0px;text-indent: 28px;color: rgb(51, 51, 51);font-family: Verdana, Arial, Helvetica, sans-serif;font-size: 13.3333px;white-space: normal;background-color: rgb(255, 255, 255)\"><span style=\";padding: 0px;font-size: 14px;font-family: 宋体\">-v,&nbsp;--verbose&nbsp;&nbsp;<span style=\"font-family:宋体\">每次创建新目录都显示信息</span></span></p><p style=\"margin: 0 auto 0 28px;padding: 0px;text-indent: 28px;color: rgb(51, 51, 51);font-family: Verdana, Arial, Helvetica, sans-serif;font-size: 13.3333px;white-space: normal;background-color: rgb(255, 255, 255)\"><span style=\";padding: 0px;font-size: 14px;font-family: 宋体\">&nbsp; &nbsp;--help&nbsp;&nbsp;&nbsp;<span style=\"font-family:宋体\">显示此帮助信息并退出</span></span></p><p style=\"margin: 0 auto 0 28px;padding: 0px;text-indent: 28px;color: rgb(51, 51, 51);font-family: Verdana, Arial, Helvetica, sans-serif;font-size: 13.3333px;white-space: normal;background-color: rgb(255, 255, 255)\"><span style=\";padding: 0px;font-size: 14px;font-family: 宋体\">&nbsp; &nbsp;--version&nbsp;&nbsp;<span style=\"font-family:宋体\">输出版本信息并退出</span></span></p><p><br/></p><p><span style=\"font-family:宋体\"><img src=\"/upload/image/20171220/1513777853911370.png\" title=\"1513777853911370.png\" alt=\"blob.png\"/></span></p><p><span style=\"font-family:宋体\">创建多级目录：mkdir -p test1/test2</span></p><p><font face=\"宋体\">创建制定权限的目录：mkdir -m 777 t3</font></p><p><font face=\"宋体\"><img src=\"/upload/image/20171220/1513778143134646.png\" title=\"1513778143134646.png\" alt=\"blob.png\"/></font></p><p><font face=\"宋体\"><img src=\"/upload/image/20171220/1513778353399076.png\" title=\"1513778353399076.png\" alt=\"blob.png\"/></font></p>',0,1,'2017-12-20 21:59:19'),(16,'每天一个linux命令（5）：rm','rm是常用的命令，该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变。','linux,rm','/upload/20171220/cf6c2198ca8dc3b2ab77d4177cbbe107.jpg','<p><span style=\"font-family: &quot;andale mono&quot;; margin: 0px; padding: 0px; text-indent: 28px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-size: 16px;\">rm是一个危险的命令，使用的时候要特别当心，尤其对于新手，否则整个系统就会毁在这个命令（比如在/（根目录）下执行rm&nbsp;*&nbsp;-rf）。所以，我们在执行rm之前最好先确认一下在哪个目录，到底要删除什么东西，操作时保持高度清醒的头脑。</span></p><p style=\"margin: 0pt auto; padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.3333px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"margin: 0px; padding: 0px; font-family: &quot;andale mono&quot;; font-size: 16px; color: rgb(0, 0, 0);\">&nbsp;&nbsp;&nbsp;-f,&nbsp;--force&nbsp;&nbsp;&nbsp;&nbsp;忽略不存在的文件，从不给出提示。</span></p><p style=\"margin: 0pt auto; padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.3333px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"margin: 0px; padding: 0px; font-family: &quot;andale mono&quot;; font-size: 16px; color: rgb(0, 0, 0);\">&nbsp; &nbsp; -i,&nbsp;--interactive&nbsp;进行交互式删除</span></p><p style=\"margin: 0pt auto; padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.3333px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"margin: 0px; padding: 0px; font-family: &quot;andale mono&quot;; font-size: 16px; color: rgb(0, 0, 0);\">&nbsp; &nbsp; -r,&nbsp;-R,&nbsp;--recursive&nbsp;&nbsp;&nbsp;指示rm将参数中列出的全部目录和子目录均递归地删除。</span></p><p style=\"margin: 0pt auto; padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.3333px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"margin: 0px; padding: 0px; font-family: &quot;andale mono&quot;; font-size: 16px; color: rgb(0, 0, 0);\">&nbsp; &nbsp; -v,&nbsp;--verbose&nbsp;&nbsp;&nbsp;&nbsp;详细显示进行的步骤</span></p><p style=\"margin: 0pt auto; padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.3333px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"margin: 0px; padding: 0px; font-family: &quot;andale mono&quot;; font-size: 16px; color: rgb(0, 0, 0);\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	--help&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显示此帮助信息并退出</span></p><p style=\"margin: 0pt auto; padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.3333px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"margin: 0px; padding: 0px; font-family: &quot;andale mono&quot;; font-size: 16px; color: rgb(146, 208, 80);\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	</span><span style=\"margin: 0px; padding: 0px; font-family: &quot;andale mono&quot;; font-size: 16px;\">--version&nbsp;&nbsp;输出版本信息并退出</span></p><p><span style=\"color: rgb(146, 208, 80);\">&nbsp;&nbsp;<span style=\"color: rgb(227, 108, 9);\">&nbsp;&nbsp;rm &nbsp;文件名 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;删除文件file，系统会先询问是否删除。</span></span></p><p><span style=\"color: rgb(227, 108, 9);\">&nbsp;&nbsp;&nbsp;&nbsp;rm -f log1.log &nbsp; &nbsp; &nbsp;&nbsp;强行删除file，系统不再提示。</span></p><p><span style=\"color: rgb(227, 108, 9);\">&nbsp;&nbsp;&nbsp;&nbsp;rm -i *.log &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 删除任何.log文件；删除前逐一询问确认&nbsp;</span></p><p><span style=\"color: rgb(227, 108, 9);\">&nbsp;&nbsp;&nbsp;&nbsp;rm -r test1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;将 test1子目录及子目录中所有档案删除</span></p><p><span style=\"color: rgb(227, 108, 9);\">&nbsp;&nbsp;&nbsp;&nbsp;rm -f f* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;删除以f开头的文件</span></p><p><br/></p>',3,1,'2017-12-20 23:17:16'),(17,'使用jQuery实现图片懒加载原理','本文给出一种利用jQuery实现图片懒加载的原理。','jQuery,懒加载,优化','/upload/20171222/61c9f83637f9a5aa4a62b858df95249d.png','<p><strong><span style=\"font-family: 黑体, SimHei; font-size: 18px;\">今天逛大佬的网站的时候发现新技能：</span></strong><span style=\"background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-size: 18px;\">使用jQuery实现图片懒加载原理</span></p><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-size: 18px;\"><span style=\"background-color: rgb(255, 255, 255); font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-size: 18px; color: rgb(255, 0, 0);\">引用来源：https://www.liaoxuefeng.com/article/00151045553343934ba3bb4ed684623b1bf00488231d88d000#0</span><br/></span></p><p><strong><span style=\"font-family: 黑体, SimHei; font-size: 18px;\"></span></strong></p><p style=\"margin-top: 15px; margin-bottom: 15px; word-wrap: break-word; white-space: pre-wrap; color: rgb(102, 102, 102); font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-size: 14px; background-color: rgb(255, 255, 255);\">本文给出一种利用jQuery实现图片懒加载的原理。它的基本思想是：在输出HTML的时候，不要直接输出<code style=\"font-size: 12px; font-family: Consolas, monospace, serif; color: rgb(221, 0, 85); white-space: nowrap; padding: 0px 4px; border: 1px solid rgb(221, 221, 221); border-radius: 3px; background: rgb(250, 250, 250);\">&lt;img src=&quot;xxx&quot;</code>，而是输出如下的<code style=\"font-size: 12px; font-family: Consolas, monospace, serif; color: rgb(221, 0, 85); white-space: nowrap; padding: 0px 4px; border: 1px solid rgb(221, 221, 221); border-radius: 3px; background: rgb(250, 250, 250);\">img</code>标签：</p><pre style=\"margin-top: 15px; margin-bottom: 15px; padding: 10px; background-color: rgb(250, 250, 250); font-stretch: normal; font-size: 12px; line-height: 18px; font-family: Consolas, monospace, serif; color: rgb(68, 68, 68); tab-size: 4; overflow: auto; border: 1px solid rgb(221, 221, 221); border-radius: 3px; word-break: break-all; word-wrap: break-word; white-space: pre-wrap;\">&lt;img&nbsp;src=&quot;/static/loading.gif&quot;&nbsp;data-src=&quot;http://真正的图片地址/xxx.jpg&quot;&gt;</pre><p style=\"margin-top: 15px; margin-bottom: 15px; word-wrap: break-word; white-space: pre-wrap; color: rgb(102, 102, 102); font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-size: 14px; background-color: rgb(255, 255, 255);\">因此，页面显示的图片是一个gif加载动画。当页面滚动时，如果图片出现在屏幕中，就利用jQuery把<code style=\"font-size: 12px; font-family: Consolas, monospace, serif; color: rgb(221, 0, 85); white-space: nowrap; padding: 0px 4px; border: 1px solid rgb(221, 221, 221); border-radius: 3px; background: rgb(250, 250, 250);\">&lt;img&gt;</code>的<code style=\"font-size: 12px; font-family: Consolas, monospace, serif; color: rgb(221, 0, 85); white-space: nowrap; padding: 0px 4px; border: 1px solid rgb(221, 221, 221); border-radius: 3px; background: rgb(250, 250, 250);\">src</code>属性替换为<code style=\"font-size: 12px; font-family: Consolas, monospace, serif; color: rgb(221, 0, 85); white-space: nowrap; padding: 0px 4px; border: 1px solid rgb(221, 221, 221); border-radius: 3px; background: rgb(250, 250, 250);\">data-src</code>的内容，浏览器就会实时加载。</p><p style=\"margin-top: 15px; margin-bottom: 15px; word-wrap: break-word; white-space: pre-wrap; color: rgb(102, 102, 102); font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-size: 14px; background-color: rgb(255, 255, 255);\">JavaScript代码如下：</p><pre style=\"margin-top: 15px; margin-bottom: 15px; padding: 10px; background-color: rgb(250, 250, 250); font-stretch: normal; font-size: 12px; line-height: 18px; font-family: Consolas, monospace, serif; color: rgb(68, 68, 68); tab-size: 4; overflow: auto; border: 1px solid rgb(221, 221, 221); border-radius: 3px; word-break: break-all; word-wrap: break-word; white-space: pre-wrap;\"><span style=\"font-size: 14px;\">// 注意: 需要引入jQuery和underscore<br/>$(function() { &nbsp; &nbsp;// 获取window的引用:<br/> &nbsp; &nbsp;var $window = $(window); &nbsp; &nbsp;// 获取包含data-src属性的img，并以jQuery对象存入数组:<br/> &nbsp; &nbsp;var lazyImgs = _.map($(&#39;img[data-src]&#39;).get(), function (i) {<br/> &nbsp; &nbsp; &nbsp; &nbsp;return $(i);<br/> &nbsp; &nbsp;}); &nbsp; &nbsp;// 定义事件函数:<br/> &nbsp; &nbsp;var onScroll = function() { &nbsp; &nbsp; &nbsp; &nbsp;// 获取页面滚动的高度:<br/> &nbsp; &nbsp; &nbsp; &nbsp;var wtop = $window.scrollTop(); &nbsp; &nbsp; &nbsp; &nbsp;// 判断是否还有未加载的img:<br/> &nbsp; &nbsp; &nbsp; &nbsp;if (lazyImgs.length &gt; 0) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 获取可视区域高度:<br/> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var wheight = $window.height(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 存放待删除的索引:<br/> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var loadedIndex = []; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 循环处理数组的每个img元素:<br/> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_.each(lazyImgs, function ($i, index) {<br/> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 判断是否在可视范围内:<br/> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if ($i.offset().top - wtop &lt; wheight) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 设置src属性:<br/> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$i.attr(&#39;src&#39;, $i.attr(&#39;data-src&#39;)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 添加到待删除数组:<br/> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;loadedIndex.unshift(index);<br/> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br/> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 删除已处理的对象:<br/> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_.each(loadedIndex, function (index) {<br/> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lazyImgs.splice(index, 1);<br/> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;});<br/> &nbsp; &nbsp; &nbsp; &nbsp;}<br/> &nbsp; &nbsp;}; &nbsp; &nbsp;// 绑定事件:<br/> &nbsp; &nbsp;$window.scroll(onScroll); &nbsp; &nbsp;// 手动触发一次:<br/> &nbsp; &nbsp;onScroll();</span><br/></pre><p style=\"margin-top: 15px; margin-bottom: 15px; word-wrap: break-word; white-space: pre-wrap; color: rgb(102, 102, 102); font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-size: 14px; background-color: rgb(255, 255, 255);\"><code style=\"font-size: 12px; font-family: Consolas, monospace, serif; color: rgb(221, 0, 85); white-space: nowrap; padding: 0px 4px; border: 1px solid rgb(221, 221, 221); border-radius: 3px; background: rgb(250, 250, 250);\">onScroll()</code>函数最后要手动触发一次，因为页面显示时，并未触发scroll事件。如果图片已经在可视区域内，这些图片仍然是loading状态，需要手动触发一次，就可以正常显示。</p><p style=\"margin-top: 15px; margin-bottom: 15px; word-wrap: break-word; white-space: pre-wrap; color: rgb(102, 102, 102); font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-size: 14px; background-color: rgb(255, 255, 255);\">要测试图片懒加载效果，可以在Chrome浏览器的控制台选择“Network”，把“Online”改为“Slow 3G”就可以模拟慢速网络下浏览器懒加载图片的效果：</p><p style=\"margin-top: 15px; margin-bottom: 15px; word-wrap: break-word; white-space: pre-wrap; color: rgb(102, 102, 102); font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-size: 14px; background-color: rgb(255, 255, 255);\"><img src=\"https://cdn.liaoxuefeng.com/cdn/files/attachments/001510456055178607ca6e299fa4f0ea776d89d48f2c564000/l\" alt=\"lazy-loading-test\"/></p><p><br/></p>',0,1,'2017-12-22 16:44:17'),(18,'依赖注入和控制反转是什么？（转）','此文档中的代码示例来讲解什么是依赖注入(DI)和控制反转(IoC)','php,DI,IOC,依赖注入,控制反转','/upload/20171227/da22d92c3626926e5d0cd0f4932db201.png','<p>好友推荐了一篇文章，学习之。</p><p><span style=\"color: rgb(255, 0, 0);\">原文地址：</span><a href=\"https://www.marser.cn/article/124.html\" style=\"color: rgb(255, 0, 0); text-decoration: underline;\"><span style=\"color: rgb(255, 0, 0);\">https://www.marser.cn/article/124.html</span></a> </p><h2 style=\"margin: 20px 0px; padding: 5px 5px 5px 10px; font-weight: normal; font-family: Verdana, &quot;Microsoft YaHei&quot;; border-left: 5px solid rgb(255, 97, 0); background: rgb(255, 255, 255); font-size: 20px; color: rgb(69, 69, 69); white-space: normal;\"><strong>依赖的产生</strong></h2><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; font-family: Verdana, &quot;Microsoft YaHei&quot;; color: rgb(69, 69, 69); font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255);\">首先，假设我们正在开发一个组件，叫SomeComponent，它需要执行的内容现在还不重要。 但是我们的组件需要依赖数据库连接。</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: inherit; color: rgb(69, 69, 69); font-size: 14px; background-color: rgb(255, 255, 255);\"><p style=\"text-indent: 0em;\"><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-family: &quot;andale mono&quot;; font-size: 16px;\">&lt;?phpclass&nbsp;SomeComponent{&nbsp;&nbsp;&nbsp;&nbsp;/**<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;数据库连接是被写死在组件的内部<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;因此，我们很难从外部替换或者改变它的行为<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;someDbTask()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$connection&nbsp;=&nbsp;new&nbsp;Connection(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;host&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;&quot;localhost&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;username&quot;&nbsp;=&gt;&nbsp;&quot;root&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;password&quot;&nbsp;=&gt;&nbsp;&quot;secret&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;dbname&quot;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;&quot;invo&quot;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>$some&nbsp;=&nbsp;new&nbsp;SomeComponent();<br/>$some-&gt;someDbTask();</span><br/></p></pre><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; font-family: Verdana, &quot;Microsoft YaHei&quot;; color: rgb(69, 69, 69); font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255);\">从上面这个例子中，可以看到数据库连接是在组件内部建立的。在我们日常开发中，类似这样的依赖关系在项目中非常常见。但是这种方法其实是不太实用的；我们不能改变创建数据库连接的参数或者选择不同的数据库系统，因为数据库连接是在组件被创建时建立的。</p><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; font-family: Verdana, &quot;Microsoft YaHei&quot;; color: rgb(69, 69, 69); font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255);\"><br/></p><h2 style=\"margin: 20px 0px; padding: 5px 5px 5px 10px; font-weight: normal; font-family: Verdana, &quot;Microsoft YaHei&quot;; border-left: 5px solid rgb(255, 97, 0); background: rgb(255, 255, 255); font-size: 20px; color: rgb(69, 69, 69); white-space: normal;\"><strong>依赖注入</strong></h2><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; font-family: Verdana, &quot;Microsoft YaHei&quot;; color: rgb(69, 69, 69); font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255);\">为了解决这样的情况，我们通过一个setter函数，在使用前注入独立外部依赖：</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: inherit; color: rgb(69, 69, 69); font-size: 14px; background-color: rgb(255, 255, 255);\">&lt;?phpclass&nbsp;SomeComponent{&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;$_connection;&nbsp;&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;设置外部传入的数据库连接\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;setConnection($connection)\n&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;_connection&nbsp;=&nbsp;$connection;\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;someDbTask()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$connection&nbsp;=&nbsp;$this-&gt;_connection;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n\n$some&nbsp;=&nbsp;new&nbsp;SomeComponent();//&nbsp;建立数据库连接$connection&nbsp;=&nbsp;new&nbsp;Connection(&nbsp;&nbsp;&nbsp;&nbsp;array(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;host&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;&quot;localhost&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;username&quot;&nbsp;=&gt;&nbsp;&quot;root&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;password&quot;&nbsp;=&gt;&nbsp;&quot;secret&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;dbname&quot;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;&quot;invo&quot;\n&nbsp;&nbsp;&nbsp;&nbsp;)\n);//&nbsp;向组件注入数据库连接$some-&gt;setConnection($connection);\n\n$some-&gt;someDbTask();</pre><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; font-family: Verdana, &quot;Microsoft YaHei&quot;; color: rgb(69, 69, 69); font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255);\">目前来看，通过setter函数来注入独立的外部依赖的方式，已经解耦了数据库连接与应用程序的依赖。这里已经使用到了控制反转（IoC）的模式。具体概念稍后再解释，还是以代码示例的方式来增加理解。</p><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; font-family: Verdana, &quot;Microsoft YaHei&quot;; color: rgb(69, 69, 69); font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255);\">我们想像一下，假设这个组件在应用内的好几个地方都需要用到，那在注入数据库连接时，我们还需要建立好几次数据库连接。 是否可以获取到数据库连接，而不用每次都创建新的连接呢？可以使用某种全局注册的方式来解决这样的问题：</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: inherit; color: rgb(69, 69, 69); font-size: 14px; background-color: rgb(255, 255, 255);\">&lt;?phpclass&nbsp;Registry{&nbsp;&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;返回数据库连接\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;function&nbsp;getConnection()\n&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;Connection(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;host&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;&quot;localhost&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;username&quot;&nbsp;=&gt;&nbsp;&quot;root&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;password&quot;&nbsp;=&gt;&nbsp;&quot;secret&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;dbname&quot;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;&quot;invo&quot;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}class&nbsp;SomeComponent{&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;$_connection;&nbsp;&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;设置外部传入的数据库连接\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;setConnection($connection)\n&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;_connection&nbsp;=&nbsp;$connection;\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;someDbTask()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$connection&nbsp;=&nbsp;$this-&gt;_connection;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n\n$some&nbsp;=&nbsp;new&nbsp;SomeComponent();//&nbsp;把数据库连接传递给组件$some-&gt;setConnection(Registry::getConnection());\n\n$some-&gt;someDbTask();</pre><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; font-family: Verdana, &quot;Microsoft YaHei&quot;; color: rgb(69, 69, 69); font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255);\">通过上述方法，我们实现了共享数据库连接，而不用每次都创建新的数据库连接。<br/>那么，让我们再扩展一下，我们可以实现2个方法，第一个方法总是创建新的数据库连接，第二方法总是使用一个共享的数据库连接：</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: inherit; color: rgb(69, 69, 69); font-size: 14px; background-color: rgb(255, 255, 255);\">&lt;?phpclass&nbsp;Registry{&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;static&nbsp;$_connection;&nbsp;&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;建立一个新的数据库连接\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;static&nbsp;function&nbsp;_createConnection()\n&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;Connection(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;host&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;&quot;localhost&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;username&quot;&nbsp;=&gt;&nbsp;&quot;root&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;password&quot;&nbsp;=&gt;&nbsp;&quot;secret&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;dbname&quot;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;&quot;invo&quot;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;只建立一个数据库连接，后面的请求共享该连接\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;function&nbsp;getSharedConnection()\n&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(self::$_connection===null)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$connection&nbsp;=&nbsp;self::_createConnection();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self::$_connection&nbsp;=&nbsp;$connection;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;self::$_connection;\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;总是返回一个新的数据库连接\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;function&nbsp;getNewConnection()\n&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;self::_createConnection();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}class&nbsp;SomeComponent{&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;$_connection;&nbsp;&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;设置外部传入的数据库连接\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;setConnection($connection)\n&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;_connection&nbsp;=&nbsp;$connection;\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;这个方法使用共享的数据库连接\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;someDbTask()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$connection&nbsp;=&nbsp;$this-&gt;_connection;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;这个方法总是使用新的数据库连接\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;someOtherDbTask($connection)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n\n$some&nbsp;=&nbsp;new&nbsp;SomeComponent();//&nbsp;注入共享的数据库连接$some-&gt;setConnection(Registry::getSharedConnection());\n\n$some-&gt;someDbTask();//&nbsp;这里总是传递一个新的数据库连接$some-&gt;someOtherDbTask(Registry::getNewConnection());</pre><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; font-family: Verdana, &quot;Microsoft YaHei&quot;; color: rgb(69, 69, 69); font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255);\">到目前为止，我们已经看到通过依赖注入怎么解决我们的问题了。把依赖作为参数来传递，而不是在内部建立它们，这使我们的应用更加容易维护和更加解耦。但是这种形式的依赖注入还有一些缺点。</p><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; font-family: Verdana, &quot;Microsoft YaHei&quot;; color: rgb(69, 69, 69); font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255);\">例如，如果这个组件有很多依赖， 我们需要创建多个参数的setter方法来传递依赖关系，或者建立一个多个参数的构造函数来传递它们，另外在使用组件前还需要每次都创建依赖，这让我们的代码像这样不易维护：</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: inherit; color: rgb(69, 69, 69); font-size: 14px; background-color: rgb(255, 255, 255);\">&lt;?php//&nbsp;创建依赖对象或从注册表中查找$connection&nbsp;=&nbsp;new&nbsp;Connection();\n$session&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;new&nbsp;Session();\n$fileSystem&nbsp;=&nbsp;new&nbsp;FileSystem();\n$filter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;new&nbsp;Filter();\n$selector&nbsp;&nbsp;&nbsp;=&nbsp;new&nbsp;Selector();//&nbsp;把依赖对象作为参数传递给构造函数$some&nbsp;=&nbsp;new&nbsp;SomeComponent($connection,&nbsp;$session,&nbsp;$fileSystem,&nbsp;$filter,&nbsp;$selector);//&nbsp;...&nbsp;或者使用setter$some-&gt;setConnection($connection);\n$some-&gt;setSession($session);\n$some-&gt;setFileSystem($fileSystem);\n$some-&gt;setFilter($filter);\n$some-&gt;setSelector($selector);</pre><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; font-family: Verdana, &quot;Microsoft YaHei&quot;; color: rgb(69, 69, 69); font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255);\">我们假设在应用内不同的地方使用和创建了这些对象。如果当我们永远不需要其中某个依赖对象时，那我们需要去删掉构造函数中的参数，或者去删掉注入的setter函数。为了解决这样的问题，我们再次回到全局注册的方式创建组件。在创建对象之前，给它增加了一个新的抽象层：</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: inherit; color: rgb(69, 69, 69); font-size: 14px; background-color: rgb(255, 255, 255);\">&lt;?phpclass&nbsp;SomeComponent{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...\n\n&nbsp;&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;定义一个工厂方法来创建SomeComponent组件所需的依赖对象\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;function&nbsp;factory()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$connection&nbsp;=&nbsp;new&nbsp;Connection();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$session&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;new&nbsp;Session();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$fileSystem&nbsp;=&nbsp;new&nbsp;FileSystem();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$filter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;new&nbsp;Filter();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$selector&nbsp;&nbsp;&nbsp;=&nbsp;new&nbsp;Selector();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;self($connection,&nbsp;$session,&nbsp;$fileSystem,&nbsp;$filter,&nbsp;$selector);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}</pre><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; font-family: Verdana, &quot;Microsoft YaHei&quot;; color: rgb(69, 69, 69); font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255);\">瞬间，我们又绕回到刚刚开始的问题了：我们再次在组件内部创建依赖的对象！一个实用又优雅的解决方法，是为依赖对象提供一个容器。</p><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; font-family: Verdana, &quot;Microsoft YaHei&quot;; color: rgb(69, 69, 69); font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255);\"><br/></p><h2 style=\"margin: 20px 0px; padding: 5px 5px 5px 10px; font-weight: normal; font-family: Verdana, &quot;Microsoft YaHei&quot;; border-left: 5px solid rgb(255, 97, 0); background: rgb(255, 255, 255); font-size: 20px; color: rgb(69, 69, 69); white-space: normal;\"><strong>容器</strong></h2><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; font-family: Verdana, &quot;Microsoft YaHei&quot;; color: rgb(69, 69, 69); font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255);\">所谓容器，从字面上来理解，就是可以装东西的东西。变量、对象属性等都可以算是容器。<br/>我们可以通过这个容器获取依赖的各个对象，这样能够降低我们这个组件的复杂性，及对依赖对象的耦合性（即解耦）：</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: inherit; color: rgb(69, 69, 69); font-size: 14px; background-color: rgb(255, 255, 255);\">&lt;?php//加载容器use&nbsp;Phalcon\\Di;class&nbsp;SomeComponent{&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;$_di;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;__construct($di)\n&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;_di&nbsp;=&nbsp;$di;\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;someDbTask()\n&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;获取数据库连接\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;总是返回一个新的连接\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$connection&nbsp;=&nbsp;$this-&gt;_di-&gt;get(&#39;db&#39;);\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;someOtherDbTask()\n&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;获取共享的数据库连接\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;每次请求都返回相同的数据库连接\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$connection&nbsp;=&nbsp;$this-&gt;_di-&gt;getShared(&#39;db&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;这个方法也需要一个过滤的依赖服务\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$filter&nbsp;=&nbsp;$this-&gt;_di-&gt;get(&#39;filter&#39;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n\n$di&nbsp;=&nbsp;new&nbsp;Di();//&nbsp;在容器中注册一个db服务$di-&gt;set(&#39;db&#39;,&nbsp;function&nbsp;()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;Connection(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;host&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;&quot;localhost&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;username&quot;&nbsp;=&gt;&nbsp;&quot;root&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;password&quot;&nbsp;=&gt;&nbsp;&quot;secret&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;dbname&quot;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;&quot;invo&quot;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;);\n});//&nbsp;在容器中注册一个filter服务$di-&gt;set(&#39;filter&#39;,&nbsp;function&nbsp;()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;Filter();\n});//&nbsp;在容器中注册一个session服务$di-&gt;set(&#39;session&#39;,&nbsp;function&nbsp;()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;Session();\n});//&nbsp;把传递服务的容器作为唯一参数传递给组件$some&nbsp;=&nbsp;new&nbsp;SomeComponent($di);\n\n$some-&gt;someDbTask();</pre><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; font-family: Verdana, &quot;Microsoft YaHei&quot;; color: rgb(69, 69, 69); font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255);\">上面这段代码并没有介绍DI容器的内部是如何运作的，下面我们自己来实现一个简单的容器：</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: inherit; color: rgb(69, 69, 69); font-size: 14px; background-color: rgb(255, 255, 255);\">class&nbsp;Container{&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;$binds;&nbsp;&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;注入服务\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;$name&nbsp;&nbsp;服务名称\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;$callback&nbsp;&nbsp;回调函数\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;set($name,&nbsp;$callback){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this&nbsp;-&gt;&nbsp;binds[$name]&nbsp;=&nbsp;$callback;\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;加载服务\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;$name&nbsp;&nbsp;服务名称\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;array&nbsp;$param&nbsp;&nbsp;参数\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;make($name,&nbsp;$param=[]){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(isset($this&nbsp;-&gt;&nbsp;binds[$name])){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;call_user_func_array($this&nbsp;-&gt;&nbsp;binds[$name],&nbsp;$param);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}</pre><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; font-family: Verdana, &quot;Microsoft YaHei&quot;; color: rgb(69, 69, 69); font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255);\">这时候，一个粗糙的容器就诞生了。我们来看看这个容器如何使用：</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: inherit; color: rgb(69, 69, 69); font-size: 14px; background-color: rgb(255, 255, 255);\">//创建一个容器$container&nbsp;=&nbsp;new&nbsp;Container();//注入db服务$container&nbsp;-&gt;&nbsp;set(&#39;db&#39;,&nbsp;function(){&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;Connection(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;host&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;&quot;localhost&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;username&quot;&nbsp;=&gt;&nbsp;&quot;root&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;password&quot;&nbsp;=&gt;&nbsp;&quot;secret&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;dbname&quot;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;&quot;invo&quot;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;);\n});//注入filter服务$container&nbsp;-&gt;&nbsp;set(&#39;filter&#39;,&nbsp;function(){&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;Fileter();\n});</pre><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; font-family: Verdana, &quot;Microsoft YaHei&quot;; color: rgb(69, 69, 69); font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255);\">如此，SomeComponent这个组件现在可以很简单的获取到它所需要的各个服务，服务采用延迟加载的方式，只有在需要使用的时候才初始化，这也节省了服务器资源。这个组件现在是高度解耦。例如，我们可以替换掉创建数据库连接的方式，它们的行为或它们的任何其他方面，也不会影响该组件。</p><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; font-family: Verdana, &quot;Microsoft YaHei&quot;; color: rgb(69, 69, 69); font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255);\">通过上述代码示例，大家应该初步了解了依赖注入和控制反转其中的原理。这里总结一下概念。<br/><br/></p><h2 style=\"margin: 20px 0px; padding: 5px 5px 5px 10px; font-weight: normal; font-family: Verdana, &quot;Microsoft YaHei&quot;; border-left: 5px solid rgb(255, 97, 0); background: rgb(255, 255, 255); font-size: 20px; color: rgb(69, 69, 69); white-space: normal;\"><strong>依赖注入（DI）</strong></h2><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; font-family: Verdana, &quot;Microsoft YaHei&quot;; color: rgb(69, 69, 69); font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255);\">依赖注入的英文全称为：Dependency Injection. 其基本原则是：应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，“查找资源”的逻辑应该从应用组件的代码中抽取出来，交给容器负责。不必自己在代码中维护对象的依赖。<br/><br/></p><h2 style=\"margin: 20px 0px; padding: 5px 5px 5px 10px; font-weight: normal; font-family: Verdana, &quot;Microsoft YaHei&quot;; border-left: 5px solid rgb(255, 97, 0); background: rgb(255, 255, 255); font-size: 20px; color: rgb(69, 69, 69); white-space: normal;\"><strong>控制反转（IoC）</strong></h2><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; font-family: Verdana, &quot;Microsoft YaHei&quot;; color: rgb(69, 69, 69); font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255);\">控制反转的英文全称为：Inversion of Control. 从上述代码示例里可以看出，把传统上由程序代码直接操控的对象的调用权转交给容器，通过容器来实现对象组件的装配与管理。也就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。这就是控制反转。主要就是依赖关系的转移。<br/><br/></p><h2 style=\"margin: 20px 0px; padding: 5px 5px 5px 10px; font-weight: normal; font-family: Verdana, &quot;Microsoft YaHei&quot;; border-left: 5px solid rgb(255, 97, 0); background: rgb(255, 255, 255); font-size: 20px; color: rgb(69, 69, 69); white-space: normal;\"><strong>容器</strong></h2><ul style=\"list-style-type: none;\" class=\" list-paddingleft-2\"><li><p>管理对象的生成、资源获取、销毁等生命周期</p></li><li><p>建立对象与对象之间的依赖关系</p></li><li><p>启动容器后，所有对象直接取用，不用编写任何一行代码来产生对象，或是建立对象之间的依赖关系</p></li></ul><p><br/></p>',0,1,'2017-12-27 11:13:56');

/*Table structure for table `snake_music` */

DROP TABLE IF EXISTS `snake_music`;

CREATE TABLE `snake_music` (
  `id` smallint(5) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(50) NOT NULL DEFAULT '' COMMENT '歌曲名称',
  `singer` varchar(30) NOT NULL DEFAULT '' COMMENT '歌手',
  `img_path` varchar(100) NOT NULL DEFAULT '' COMMENT '图片地址',
  `music_path` varchar(100) NOT NULL DEFAULT '' COMMENT '音乐地址',
  `status` tinyint(4) NOT NULL DEFAULT '1' COMMENT '状态',
  `create_time` datetime NOT NULL COMMENT '添加时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `snake_music` */

/*Table structure for table `snake_node` */

DROP TABLE IF EXISTS `snake_node`;

CREATE TABLE `snake_node` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `node_name` varchar(155) NOT NULL DEFAULT '' COMMENT '节点名称',
  `control_name` varchar(155) NOT NULL DEFAULT '' COMMENT '控制器名',
  `action_name` varchar(155) NOT NULL COMMENT '方法名',
  `is_menu` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否是菜单项 1不是 2是',
  `type_id` int(11) NOT NULL COMMENT '父级节点id',
  `style` varchar(155) DEFAULT '' COMMENT '菜单样式',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

/*Data for the table `snake_node` */

insert  into `snake_node`(`id`,`node_name`,`control_name`,`action_name`,`is_menu`,`type_id`,`style`) values (1,'用户管理','#','#',2,0,'fa fa-users'),(2,'管理员管理','user','index',2,1,''),(3,'添加管理员','user','useradd',1,2,''),(4,'编辑管理员','user','useredit',1,2,''),(5,'删除管理员','user','userdel',1,2,''),(6,'角色管理','role','index',2,1,''),(7,'添加角色','role','roleadd',1,6,''),(8,'编辑角色','role','roleedit',1,6,''),(9,'删除角色','role','roledel',1,6,''),(10,'分配权限','role','giveaccess',1,6,''),(11,'系统管理','#','#',2,0,'fa fa-desktop'),(12,'数据备份/还原','data','index',2,11,''),(13,'备份数据','data','importdata',1,12,''),(14,'还原数据','data','backdata',1,12,''),(15,'菜单管理','node','index',2,1,''),(16,'添加节点','node','nodeadd',1,15,''),(17,'编辑节点','node','nodeedit',1,15,''),(18,'删除节点','node','nodedel',1,15,''),(19,'文章管理','articles','index',2,0,'fa fa-book'),(20,'文章列表','articles','index',2,19,''),(21,'添加文章','articles','articleadd',1,19,''),(22,'编辑文章','articles','articleedit',1,19,''),(23,'删除文章','articles','articledel',1,19,''),(24,'上传图片','articles','uploadImg',1,19,''),(25,'标签管理','#tag','#',2,0,'fa fa-bookmark'),(26,'标签云','tag','index',2,25,''),(27,'添加标签','tag','tagadd',1,25,''),(28,'音乐管理','#music','#',2,0,'fa fa-music'),(29,'音乐库','music','index',2,28,''),(30,'添加音乐','music','musicadd',1,28,'');

/*Table structure for table `snake_role` */

DROP TABLE IF EXISTS `snake_role`;

CREATE TABLE `snake_role` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `role_name` varchar(155) NOT NULL COMMENT '角色名称',
  `rule` varchar(255) DEFAULT '' COMMENT '权限节点数据',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

/*Data for the table `snake_role` */

insert  into `snake_role`(`id`,`role_name`,`rule`) values (1,'超级管理员','*'),(2,'系统维护员','1,2,3,4,5,6,7,8,9,10');

/*Table structure for table `snake_tag` */

DROP TABLE IF EXISTS `snake_tag`;

CREATE TABLE `snake_tag` (
  `id` smallint(5) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(30) NOT NULL DEFAULT '' COMMENT '标签名',
  `status` tinyint(4) NOT NULL DEFAULT '1' COMMENT '状态 1正常 0删除 2禁用',
  `create_time` int(11) NOT NULL DEFAULT '0' COMMENT '创建时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;

/*Data for the table `snake_tag` */

insert  into `snake_tag`(`id`,`title`,`status`,`create_time`) values (1,'PHP',1,1512360418),(3,'Mysql',1,1512539690),(4,'Linux',1,1512541759),(5,'jQuery',1,1513931666),(6,'性能',1,1514346408);

/*Table structure for table `snake_user` */

DROP TABLE IF EXISTS `snake_user`;

CREATE TABLE `snake_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_name` varchar(255) COLLATE utf8_bin NOT NULL DEFAULT '' COMMENT '用户名',
  `password` varchar(255) COLLATE utf8_bin NOT NULL DEFAULT '' COMMENT '密码',
  `login_times` int(11) NOT NULL DEFAULT '0' COMMENT '登陆次数',
  `last_login_ip` varchar(255) COLLATE utf8_bin NOT NULL DEFAULT '' COMMENT '最后登录IP',
  `last_login_time` int(11) NOT NULL DEFAULT '0' COMMENT '最后登录时间',
  `real_name` varchar(255) COLLATE utf8_bin NOT NULL DEFAULT '' COMMENT '真实姓名',
  `status` int(1) NOT NULL DEFAULT '0' COMMENT '状态',
  `role_id` int(11) NOT NULL DEFAULT '1' COMMENT '用户角色id',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COLLATE=utf8_bin;

/*Data for the table `snake_user` */

insert  into `snake_user`(`id`,`user_name`,`password`,`login_times`,`last_login_ip`,`last_login_time`,`real_name`,`status`,`role_id`) values (1,'admin','21232f297a57a5a743894a0e4a801fc3',63,'127.0.0.1',1514379421,'admin',1,1);

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
